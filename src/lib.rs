//! apple-main: Integrate async Rust with Apple's main-thread-bound frameworks
//!
//! This crate provides seamless integration between async Rust (tokio) and Apple's
//! main-thread-bound frameworks like Virtualization.framework and AppKit.
//!
//! # Threading Model
//!
//! On macOS, many Apple frameworks require operations to run on the main thread.
//! This crate handles the complexity by:
//!
//! - **Main thread**: Runs CFRunLoop, processing dispatch queue events
//! - **Tokio threads**: Run your async code via `#[apple_main::main]` or `#[harness_test]`
//! - **`on_main()`/`on_main_sync()`**: Dispatch closures to the main thread from tokio
//!
//! ```text
//! ┌─────────────────┐     dispatch      ┌─────────────────┐
//! │  Tokio Thread   │ ───────────────▶  │   Main Thread   │
//! │  (your code)    │                   │   (CFRunLoop)   │
//! │                 │ ◀───────────────  │                 │
//! └─────────────────┘     result        └─────────────────┘
//! ```
//!
//! # API Guide
//!
//! ## For Applications
//!
//! Use `#[apple_main::main]` for your entry point:
//!
//! ```ignore
//! #[apple_main::main]
//! async fn main() {
//!     let config = apple_main::on_main(|| {
//!         VZVirtualMachineConfiguration::new()
//!     }).await;
//! }
//! ```
//!
//! ## For Tests
//!
//! Use `#[apple_main::harness_test]` with a custom test harness:
//!
//! ```ignore
//! // Cargo.toml: [[test]] name = "my_test" harness = false
//!
//! #[apple_main::harness_test]
//! async fn test_vm() {
//!     apple_main::on_main(|| { /* ... */ }).await;
//! }
//!
//! apple_main::test_main!();
//! ```
//!
//! ## For Framework Integration (Criterion, etc.)
//!
//! When integrating with frameworks that control the entry point, use the
//! low-level APIs directly:
//!
//! ```ignore
//! fn my_benchmark(c: &mut Criterion) {
//!     // Runtime is auto-initialized by criterion_main!
//!     apple_main::block_on(async {
//!         apple_main::on_main(|| { /* ... */ }).await
//!     });
//! }
//!
//! apple_main::criterion_main!(benches);
//! ```
//!
//! # Cross-Platform Support
//!
//! All APIs work transparently on non-Apple platforms:
//! - `on_main()` / `on_main_sync()` execute inline (no thread switching)
//! - `is_main_thread()` always returns `true`
//! - `#[apple_main::main]` expands to standard `#[tokio::main]`
//!
//! This means you can write cross-platform code that "just works" everywhere.

mod dispatch;
mod platform;
mod runtime;
mod test_harness;

pub use apple_main_macros::{harness_test, main, test};
pub use dispatch::{on_main, on_main_sync};
pub use runtime::{block_on, init_runtime, runtime};
pub use test_harness::{run_tests, TestCase};

#[cfg(feature = "unstable-test-framework")]
pub use test_harness::test_runner;

#[cfg(target_os = "macos")]
pub use platform::apple::is_main_thread;

#[cfg(not(target_os = "macos"))]
pub use platform::other::is_main_thread;

pub use inventory;
pub use libtest_mimic;

#[cfg(feature = "criterion")]
pub use criterion;

#[cfg(feature = "unstable-criterion-framework")]
pub use criterion_macro;

/// Criterion test runner for use with `#![test_runner(apple_main::criterion_runner)]`.
///
/// This enables Rust's unstable `custom_test_frameworks` feature for Criterion benchmarks,
/// eliminating the need for `criterion_main!()` and `[[bench]] harness = false`.
///
/// # Example
///
/// ```ignore
/// // Requires nightly and the unstable-criterion-framework feature
/// #![feature(custom_test_frameworks)]
/// #![test_runner(apple_main::criterion_runner)]
///
/// use apple_main::criterion::Criterion;
/// use apple_main::criterion_macro::criterion;
///
/// #[criterion]
/// fn my_benchmark(c: &mut Criterion) {
///     c.bench_function("example", |b| {
///         b.iter(|| apple_main::block_on(async { /* ... */ }))
///     });
/// }
/// // No criterion_main!() needed!
/// ```
#[cfg(all(feature = "criterion", feature = "unstable-criterion-framework"))]
pub fn criterion_runner(benchmarks: &[&dyn Fn()]) {
    let benchmarks_ptr = benchmarks.as_ptr() as usize;
    let benchmarks_len = benchmarks.len();

    __internal::run_criterion_on_thread(move || {
        // SAFETY: Reconstructing the slice from raw pointer is sound because:
        // 1. The pointer came from a valid slice, so it's properly aligned
        // 2. The benchmarks are static function pointers generated by #[criterion],
        //    so they have 'static lifetime and remain valid
        // 3. We use usize to cross the thread boundary because &[&dyn Fn()] isn't
        //    Send (dyn Fn() isn't Sync), but the underlying data is actually safe
        //    to access from another thread since it's all static
        // 4. The main thread blocks in run_criterion_on_thread until this closure
        //    completes, so the original slice's stack frame remains valid
        // 5. We reconstruct with the exact same length, preventing out-of-bounds access
        let benchmarks: &[&dyn Fn()] = unsafe {
            std::slice::from_raw_parts(benchmarks_ptr as *const &dyn Fn(), benchmarks_len)
        };

        for bench in benchmarks {
            bench();
        }
    });
}

#[doc(hidden)]
pub mod __internal {
    #[cfg(target_os = "macos")]
    pub fn run_main_loop() -> ! {
        // SAFETY: CFRunLoopRun is safe to call from the main thread.
        // This function is designed to be the main thread's blocking event loop.
        // It has no preconditions beyond being called from a thread with a runloop.
        unsafe {
            CFRunLoopRun();
        }
        unreachable!("CFRunLoopRun returned")
    }

    #[cfg(target_os = "macos")]
    pub fn exit_main_loop(code: i32) -> ! {
        ::dispatch::Queue::main().exec_async(move || {
            ::std::process::exit(code);
        });
        // Block forever until the dispatch executes and exits
        loop {
            ::std::thread::park();
        }
    }

    #[cfg(target_os = "macos")]
    #[link(name = "CoreFoundation", kind = "framework")]
    extern "C" {
        fn CFRunLoopRun();
    }

    #[cfg(not(target_os = "macos"))]
    pub fn run_main_loop() -> ! {
        panic!("run_main_loop should not be called on non-macOS platforms")
    }

    #[cfg(not(target_os = "macos"))]
    pub fn exit_main_loop(code: i32) -> ! {
        ::std::process::exit(code);
    }

    #[cfg(all(feature = "criterion", target_os = "macos"))]
    pub fn run_criterion_on_thread<F>(run_benchmarks: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let (tx, rx) = ::std::sync::mpsc::channel::<()>();

        ::std::thread::spawn(move || {
            rx.recv().expect("failed to receive start signal from main thread");

            crate::init_runtime();

            run_benchmarks();

            crate::criterion::Criterion::default()
                .configure_from_args()
                .final_summary();

            ::dispatch::Queue::main().exec_async(|| {
                ::core_foundation::runloop::CFRunLoop::get_current().stop();
            });
        });

        ::dispatch::Queue::main().exec_async(move || {
            tx.send(()).expect("failed to send start signal to benchmark thread");
        });

        ::core_foundation::runloop::CFRunLoop::run_current();
    }

    #[cfg(all(feature = "criterion", not(target_os = "macos")))]
    pub fn run_criterion_on_thread<F>(run_benchmarks: F)
    where
        F: FnOnce(),
    {
        crate::init_runtime();

        run_benchmarks();

        crate::criterion::Criterion::default()
            .configure_from_args()
            .final_summary();
    }
}

/// Macro to generate a main function for test files with `harness = false`.
///
/// # Example
///
/// ```ignore
/// // tests/my_tests.rs (with harness = false in Cargo.toml)
///
/// #[apple_main::harness_test]
/// async fn test_vm_creation() {
///     // Your test code - can use on_main() since CFRunLoop is active
///     let config = apple_main::on_main(|| {
///         VZVirtualMachineConfiguration::new()
///     }).await;
/// }
///
/// apple_main::test_main!();
/// ```
#[macro_export]
macro_rules! test_main {
    () => {
        fn main() {
            $crate::run_tests();
        }
    };
}

/// Macro to generate a main function for Criterion benchmarks.
///
/// This replaces `criterion_main!` and handles CFRunLoop setup on macOS
/// so that `on_main_sync()` works correctly in benchmarks.
///
/// # Example
///
/// ```ignore
/// use apple_main::criterion::{criterion_group, Criterion};
///
/// fn vm_benchmark(c: &mut Criterion) {
///     c.bench_function("vm_create", |b| {
///         b.iter(|| {
///             apple_main::on_main_sync(|| {
///                 VZVirtualMachineConfiguration::new()
///             })
///         })
///     });
/// }
///
/// criterion_group!(benches, vm_benchmark);
/// apple_main::criterion_main!(benches);
/// ```
#[cfg(feature = "criterion")]
#[macro_export]
macro_rules! criterion_main {
    ($($group:path),+ $(,)?) => {
        fn main() {
            $crate::__internal::run_criterion_on_thread(|| {
                $($group();)+
            });
        }
    };
}
